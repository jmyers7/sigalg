"""
Base class for discrete-time stochastic processes.

This module provides the base class for processes evolving at discrete time
steps, with methods for exact probability calculations and conditional
expectations.
"""

from .StochasticProcess import StochasticProcess


class DiscreteTimeStochasticProcess(StochasticProcess):
    """
    Base class for discrete-time stochastic processes.

    Extends StochasticProcess with methods specific to discrete-time processes:
    sample space enumeration, joint probability computation, and conditional
    expectation with respect to sigma-algebras.

    Parameters
    ----------
    chain_length : int, default=3
        Number of time steps

    Attributes
    ----------
    chain_length : int
        Number of time steps
    omega : pandas.DataFrame or None
        Sample space containing all possible sequences and probabilities.
        Populated by setup_sample_space().

    Notes
    -----
    Sample space enumeration has exponential complexity in chain_length.
    For long chains, use simulate() instead of setup_sample_space().

    See Also
    --------
    StochasticProcess : Parent class for all processes
    """

    def __init__(self, chain_length=3):
        """
        Initialize discrete-time process.

        Parameters
        ----------
        chain_length : int, default=3
            Number of time steps
        """
        super().__init__()
        self.chain_length = chain_length
        self.omega = None

    def setup_sample_space(self):
        """
        Generate complete sample space.

        Creates DataFrame with all possible sequences and their joint
        probabilities. Feasible only for small chain_length.

        Returns
        -------
        self
            Returns self for method chaining

        Raises
        ------
        NotImplementedError
            Subclasses must implement this method

        Warnings
        --------
        Complexity is O(state_space_size^chain_length). Use simulate() for
        long chains.
        """
        raise NotImplementedError

    def joint_prob(self, X):
        """
        Compute joint probability P(X_1, ..., X_n).

        Parameters
        ----------
        X : array-like
            State sequence

        Returns
        -------
        float
            Joint probability

        Raises
        ------
        NotImplementedError
            Subclasses must implement this method
        """
        raise NotImplementedError

    def conditional_expectation(self, Y, sigma_algebra):
        """
        Compute conditional expectation E(Y | sigma-algebra).

        Computes E(Y | G) where G is the sigma-algebra generated by specified
        random variables.

        Parameters
        ----------
        Y : str or callable
            Random variable. If str, column name in omega. If callable,
            function that takes omega and returns a Series.
        sigma_algebra : list of str
            Column names generating the conditioning sigma-algebra

        Returns
        -------
        pandas.Series
            Conditional expectation indexed by sigma-algebra atoms

        Raises
        ------
        ValueError
            If setup_sample_space() has not been called

        Examples
        --------
        >>> mc = TwoStateMarkovChain(chain_length=3)
        >>> mc.setup_sample_space()
        >>> E_S2_X1 = mc.conditional_expectation("S2", ["X1"])
        >>> E_S3_X1X2 = mc.conditional_expectation("S3", ["X1", "X2"])
        """
        if self.omega is None:
            raise ValueError("Call setup_sample_space() first")

        if isinstance(Y, str):
            Y_values = self.omega[Y]
        else:
            Y_values = Y(self.omega)

        p_cond_col = f"p_{'_'.join(sigma_algebra)}"
        self.omega[p_cond_col] = self.omega.groupby(sigma_algebra)["p"].transform(
            lambda x: x / x.sum()
        )

        result = self.omega.groupby(sigma_algebra).apply(
            lambda g: (Y_values.loc[g.index] * g[p_cond_col]).sum(),
            include_groups=False,
        )

        self.omega.drop(columns=[p_cond_col], inplace=True)

        return result

    def _get_x_values(self, series):
        """X-axis is discrete time steps."""
        return range(len(series))
