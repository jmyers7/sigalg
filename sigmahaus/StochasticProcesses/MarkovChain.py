"""
Abstract base class for Markov chain implementation.

This module defines the MarkovChain class, a discrete-time stochastic
process characterized by the Markov property. It includes methods for
sample space generation, joint probability computation, and simulation of
multiple chains.
"""

from .DiscreteTimeStochasticProcess import DiscreteTimeStochasticProcess
import pandas as pd
import numpy as np
from itertools import product
from abc import abstractmethod


class MarkovChain(DiscreteTimeStochasticProcess):
    """
    Base class for Markov chains. Extends DiscreteTimeStochasticProcess.

    Parameters
    ----------
    init_prob : array-like
        Initial state probabilities
    trajectory_length : int, default=3
        Number of time steps

    Attributes
    ----------
    init_prob : array-like
        Initial state probabilities
    num_states : int
        Number of states
    order : int
        Order of the Markov chain

    Notes
    -----
    Sample space enumeration has exponential complexity in trajectory_length.
    For long chains, use simulate() instead of setup_sample_space().

    See Also
    --------
    DiscreteTimeStochasticProcess : Parent class for discrete-time processes    
    """

    def __init__(self, init_prob, trajectory_length=3):
        """
        Initialize Markov chain.

        Parameters
        ----------
        init_prob : array-like
            Initial state probabilities
        trajectory_length : int, default=3
            Number of time steps
        
        Notes
        -----
        Subclasses should set self.order.
        """
        super().__init__(trajectory_length)
        self.num_states = init_prob.shape[0]
        self.init_prob = init_prob
        self.order = None

    def setup_sample_space(self):
        """
        Generate complete sample space.

        Creates DataFrame with all possible sequences and their joint
        probabilities. Feasible only for small trajectory_length.

        Returns
        -------
        self
            Returns self for method chaining
        """
        omega_cardinality = self.num_states**self.trajectory_length
        if omega_cardinality > 1000:  # Reasonable threshold
            raise ValueError(
                "Sample space size exceeds threshold 1000. Use simulate() instead."
            )
        # Generate all possible sequences
        sequences = list(
            product(list(range(self.num_states)), repeat=self.trajectory_length)
        )
        # Create DataFrame with all possible sequences and their joint probabilities
        column_names = [f"X{i + 1}" for i in range(self.trajectory_length)]
        self.omega = pd.DataFrame(sequences, columns=column_names)
        self.omega["p"] = self.omega[column_names].apply(
            lambda row: self.joint_prob(row.tolist()),
            axis=1,
        )
        return self

    @abstractmethod
    def _check_prob(self, init_prob):
        """
        Check if initial probabilities are valid.

        Parameters
        ----------
        init_prob : array-like
            Initial probabilities

        Raises
        ------
        ValueError
            If initial probabilities are invalid
        
        Notes
        -----
        For subclasses, this method will accept higher-order transition structures.
        """
        pass

    def _get_plot_data(self, trajectories, cumulative=False, **kwargs):
        """
        Get plot data for Markov chain. Allow for cumulative plotting.
        
        Parameters
        ----------
        trajectories : array-like
            Simulated trajectories generated by simulate()
        cumulative : bool, default=False
            If True, plot cumulative sums of states
        
        Returns
        -------
        data : array-like
            Data to plot
        ylabel : str
            Y-axis label, either "state" or "cumulative sum"
        """
        if cumulative:
            data = np.cumsum(trajectories, axis=1)
            ylabel = "cumulative sum"
            self._plot_type = "cumulative sums"
            final_states = data[:, -1]
            sorted_indices = np.argsort(final_states)
            data = data[sorted_indices]
        else:
            data = trajectories
            ylabel = "state"
            self._plot_type = "states"
        return data, ylabel

    def _get_plot_title(self, **kwargs):
        """Get title for Markov chain plot."""
        plot_type = getattr(self, "_plot_type", "trajectories")
        return f"order-{self.order} Markov chain {plot_type} (number of states={self.num_states + 1})"
